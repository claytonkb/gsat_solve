// gsat_solve.c
//

#include "sat_tools.h"
#include "sls.h"
#include "cnf.h"
#include "cnf_parse.h"
#include "babel.h"
#include "introspect.h"
#include "introspect_sat.h"
#include "bstring.h"
#include "io.h"
#include "mem.h"
#include <stdlib.h>
#include <time.h>

void dev_prompt(void);
void dev_get_line(char *buffer, FILE *stream);
void dev_menu(void);
char *slurp_file(char *filename);
FILE *open_file(char *filename, const char *attr);
int file_size(FILE *file);

int dev_i;


int main(void){

    srand((unsigned)time(NULL));
    sls_mt_srand(rand());

    dev_prompt();

    _msg("Done");

}


//
//
void dev_prompt(void){

    char *cmd_code_str;
    int   cmd_code=0;

    char buffer[256];

    int i,j;

    char *cnf_file;
    clause_list *cl;
    st_state *st;

    babel_env *be = babel_env_new(1);

    mword *ACC=be->nil;

    int approx_num_lines;
    mword *result;
    mword str_offset;

    mword *temp;
    mword  tempv;

    int    tries;
    int    flips;

    mword *clause;
    int tempi;

    _say("type 0 for menu");

    while(1){

        _prn("% ");

        dev_get_line(buffer, stdin);

        cmd_code_str = strtok(buffer, " ");
        if(cmd_code_str == NULL) continue;
        cmd_code = atoi(cmd_code_str);

        switch(cmd_code){
            case 0:
                dev_menu();
                break;

            case 1:
                _say("cmd_code==1");
                break;

            case 2:
                _say("exiting");
                return;

            case 3:
                cmd_code_str = strtok(NULL, " ");
                if(cmd_code_str == NULL){ _say("not enough arguments"); continue; }

                cnf_file = slurp_file(cmd_code_str);
                cl = parse_DIMACS(cnf_file);
                st = malloc(sizeof(st_state));
                st->cl = cl;
                st_init(be, st);

                break;

            case 4:
                tries = 100;
                flips = 1000;
                cmd_code_str = strtok(NULL, " ");
                if(cmd_code_str != NULL)//{ _say("not enough arguments"); continue; }
                    tries = atoi((char*)cmd_code_str);

                cmd_code_str = strtok(NULL, " ");
                if(cmd_code_str != NULL)//{ _say("not enough arguments"); continue; }
                    flips = atoi((char*)cmd_code_str);

                _dd(st->cl->num_clauses);
                tempv = sls_gsat_solve(st, tries, flips);
                _dd(tempv);

                break;

            case 5:
                printf("\nv ");
                for(i=1; i<=st->cl->num_variables; i++){
                    tempv = i;
                    if(cnf_var_read(st,i) == DEC_ASSIGN1_VS
                        || cnf_var_read(st,i) == IMP_ASSIGN1_VS)
                        printf("%d ", (int)tempv);
                    else
                        printf("%d ", -1*(int)tempv);
                }
                printf("\n\n");
                break;

            case 6:
                approx_num_lines = cl->num_assignments+cl->num_variables;
                result = mem_new_str(be, 80*approx_num_lines+100, 0);
                str_offset = 0;

                bsprintf(be, result, &str_offset, "c Auto-generated by gsat_solve\n");
                bsprintf(be, result, &str_offset, "p cnf %d %d\n", cl->num_variables, cl->num_clauses);

                for(i=1; i<=st->cl->num_variables; i++){
                    tempv=i;
                    if(cnf_var_read(st,i) == DEC_ASSIGN1_VS
                        || cnf_var_read(st,i) == IMP_ASSIGN1_VS)
                        bsprintf(be, result, &str_offset, "%d 0\n", (int)tempv);
                    else
                        bsprintf(be, result, &str_offset, "%d 0\n", -1*(int)tempv);
                }

                for(i=0;i<size(st->clause_array);i++){
                    clause = rdp(st->clause_array,i);
                    for(j=0;j<size(clause);j++){
                        tempi = rdv(clause,j);
                        bsprintf(be, result, &str_offset, "%d ", tempi);
                    }
                    bsprintf(be, result, &str_offset, "0\n");
                }
                bsprintf(be, result, &str_offset, "\n\n");

                array_shrink(be,result,0,str_offset-1,U8_ASIZE);
                //fprintf(stderr, result);
                io_spit(be, "work/check.cnf", result, U8_ASIZE, OVERWRITE);
                _say("result CNF ==> work/check.cnf");

                break;

            case 7:
                temp = introspect_sat_gv(be, st, cl);
                io_spit(be, "work/test.dot", temp, U8_ASIZE, OVERWRITE);
                _say("introspect_sat_gv() ==> work/test.dot");
                break;

            default:
                _say("unrecognized cmd_code");
                dev_menu();
                break;
        }

        for(i=0;i<256;i++){ buffer[i]=0; } // zero out the buffer

    }

}


//
//
void dev_get_line(char *buffer, FILE *stream){

    int c, i=0;

    while(1){ //FIXME unsafe, wrong
        c = fgetc(stream);
        if(c == EOF || c == '\n'){
            break;
        }
        buffer[i] = c;
        i++;
    }

    buffer[i] = '\0';

}


//
//
void dev_menu(void){

    _say( "\n0     .....    list command codes\n"
            "2     .....    exit\n"
            "3     .....    load & parse CNF file\n"
            "4     .....    invoke GSAT solver on loaded CNF\n"
            "5     .....    display GSAT solver result\n"
            "6     .....    write GSAT solver result to work/check.cnf\n"
            "7     .....    write CNF graph to work/cnf_graph.dot\n");

}


//
//
char *slurp_file(char *filename){

    FILE *f = open_file((char*)filename, "r");
    int size = file_size(f);

    char *file_buffer = (char*)malloc(size+1);
    size_t dummy = fread((char*)file_buffer, 1, size, f);

    fclose(f);

    return file_buffer;

}


//
//
FILE *open_file(char *filename, const char *attr){

    FILE* file;

    file = fopen((char*)filename, attr);

    if(file==NULL)
        _fatal((char*)filename);

    return file;

}


//
//
int file_size(FILE *file){

    fseek(file, 0L, SEEK_END);
    int size = ftell(file);
    rewind(file);

    return size;

}


// Clayton Bauman 2018

